/*Ares, a tactical space combat game.Copyright (C) 1997, 1999-2001, 2008 Nathan LamontThis program may be used, mofified, and redistributed either under the termsof the GNU General Public License version 2 or the GNU Lesser General PublicLicense version 3. See `LICENSE.md` for details.*//******************************************\|**| Ares_External_File.c\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#pragma mark _this library includes_/* - this project*******************************************/#ifndef kSpaceObject#include "Space Object Handling.h"#endif#include "Scenario_Data.h"#include "Ares Global Type.h"#include "Scenario.h"#include "Scenario Maker.h"#include "Races.h"#include "Handle Handling.h"#include "Error.h"#include "Debug.h"#include "Ambrosia_Serial.h"#include "Ares_External_File.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/extern	aresGlobalType			*gAresGlobal;extern	Handle					gBaseObjectData, gObjectActionData;#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/OSErr EF_OpenExternalFile( void){	Handle	tempScenarioInfo = nil;	short	oldResFile = CurResFile(), homeResFile;		if ( gAresGlobal->externalFileRefNum != -1)		CloseResFile( gAresGlobal->externalFileRefNum);		if ( gAresGlobal->externalFileSpec.name[0] > 0)	{		gAresGlobal->externalFileRefNum =			FSpOpenResFile( &gAresGlobal->externalFileSpec, fsRdPerm);				if ( gAresGlobal->externalFileRefNum > 0)			UseResFile( gAresGlobal->externalFileRefNum);		else		{			UseResFile( oldResFile);			gAresGlobal->externalFileRefNum = -1;			return paramErr;		}	} else	{		gAresGlobal->externalFileRefNum = -1;	}				// scenario info	tempScenarioInfo = GetResource( 'nlAG', 128);	if ( tempScenarioInfo != nil)	{		homeResFile = HomeResFile( tempScenarioInfo);		if (( homeResFile == gAresGlobal->externalFileRefNum) ||			( gAresGlobal->externalFileSpec.name[0] == 0))		{			BlockMove( *tempScenarioInfo, &gAresGlobal->scenarioFileInfo,				sizeof( scenarioInfoType));		} else		{			UseResFile( oldResFile);			gAresGlobal->externalFileRefNum = -1;			return resNotFound;		}		ReleaseResource( tempScenarioInfo);	} else	{		UseResFile( oldResFile);		gAresGlobal->externalFileRefNum = -1;		return resNotFound;	}		// scenario stuff	if ( gAresGlobal->gScenarioData != nil)	{		HHDeregisterHandle( &gAresGlobal->gScenarioData);		DisposeHandle( gAresGlobal->gScenarioData);		gAresGlobal->gScenarioData = nil;	}	if ( gAresGlobal->gScenarioInitialData != nil)	{		HHDeregisterHandle( &gAresGlobal->gScenarioInitialData);		DisposeHandle( gAresGlobal->gScenarioInitialData);		gAresGlobal->gScenarioInitialData = nil;	}	if ( gAresGlobal->gScenarioConditionData != nil)	{		HHDeregisterHandle( &gAresGlobal->gScenarioConditionData);		DisposeHandle( gAresGlobal->gScenarioConditionData);		gAresGlobal->gScenarioConditionData = nil;	}	if ( gAresGlobal->gScenarioBriefData != nil)	{		HHDeregisterHandle( &gAresGlobal->gScenarioBriefData);		DisposeHandle( gAresGlobal->gScenarioBriefData);		gAresGlobal->gScenarioBriefData = nil;	}		// races	if ( gAresGlobal->gRaceData != nil)	{		HHDeregisterHandle( &gAresGlobal->gRaceData);		DisposeHandle( gAresGlobal->gRaceData);		gAresGlobal->gRaceData = nil;	}		// object stuff	if ( gBaseObjectData != nil)	{		HHDeregisterHandle( &gBaseObjectData);		DisposeHandle( gBaseObjectData);		gBaseObjectData = nil;	}		if ( gObjectActionData != nil)	{		HHDeregisterHandle( &gObjectActionData);		DisposeHandle( gObjectActionData);		gObjectActionData = nil;	}	// load all the new stuff		// scenario stuff	gAresGlobal->gScenarioData = GetResource( kScenarioResType, kScenarioResID);	if ( gAresGlobal->gScenarioData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kScenarioDataError, -1, -1, -1, __FILE__, 2);		return( RESOURCE_ERROR);	}	if ( GetHandleSize( gAresGlobal->gScenarioData) <= 0)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kScenarioDataError, -1, -1, -1, __FILE__, 2);		return( RESOURCE_ERROR);	}	DetachResource( gAresGlobal->gScenarioData);	mDataHandleLockAndRegister( gAresGlobal->gScenarioData, nil, nil, CorrectThisScenarioPtr, "\pgAresGlobal->gScenarioData")		gAresGlobal->scenarioNum = GetHandleSize( gAresGlobal->gScenarioData) /		sizeof( scenarioType);		gAresGlobal->gScenarioInitialData = GetResource( kScenarioInitialResType, kScenarioInitialResID);	if ( gAresGlobal->gScenarioInitialData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kScenarioInitialDataError, -1, -1, -1, __FILE__, 3);		return( RESOURCE_ERROR);	}	DetachResource( gAresGlobal->gScenarioInitialData);	mDataHandleLockAndRegister( gAresGlobal->gScenarioInitialData, nil, nil, nil, "\pgAresGlobal->gScenarioInitialData")		gAresGlobal->maxScenarioInitial = GetHandleSize(		gAresGlobal->gScenarioInitialData) / sizeof( scenarioInitialType);			gAresGlobal->gScenarioConditionData = GetResource( kScenarioConditionResType, kScenarioConditionResID);	if ( gAresGlobal->gScenarioConditionData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kScenarioConditionDataError, -1, -1, -1, __FILE__, 4);		return( RESOURCE_ERROR);	}	DetachResource( gAresGlobal->gScenarioConditionData);	mDataHandleLockAndRegister( gAresGlobal->gScenarioConditionData, nil, nil, nil, "\pgAresGlobal->gScenarioConditionData")		gAresGlobal->maxScenarioCondition = GetHandleSize(		gAresGlobal->gScenarioConditionData) / sizeof( scenarioConditionType);			gAresGlobal->gScenarioBriefData = GetResource( kScenarioBriefResType, kScenarioBriefResID);	if ( gAresGlobal->gScenarioBriefData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kScenarioBriefDataError, -1, -1, -1, __FILE__, 5);		return( RESOURCE_ERROR);	}	DetachResource( gAresGlobal->gScenarioBriefData);	mDataHandleLockAndRegister( gAresGlobal->gScenarioBriefData, nil, nil, nil, "\pgAresGlobal->gScenarioBriefData")	gAresGlobal->maxScenarioBrief = GetHandleSize(		gAresGlobal->gScenarioBriefData) / sizeof( briefPointType);			// races	if ( gAresGlobal->gRaceData == nil)	{		gAresGlobal->gRaceData = GetResource( kRaceResType, kRaceResID);		if ( gAresGlobal->gRaceData == nil)		{			ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kReadRaceDataError, -1, -1, -1, __FILE__, 1);			return( RESOURCE_ERROR);		}		DetachResource( gAresGlobal->gRaceData);		mDataHandleLockAndRegister( gAresGlobal->gRaceData, nil, nil, nil, "\pgAresGlobal->gRaceData")	}		// object stuff		gBaseObjectData = GetResource( kBaseObjectResType, kBaseObjectResID);	if ( gBaseObjectData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kReadBaseObjectDataError, -1, -1, -1, __FILE__, 2);		return( MEMORY_ERROR);	}	DetachResource( gBaseObjectData);	mDataHandleLockAndRegister( gBaseObjectData, nil, nil, nil, "\pgBaseObjectData")	gAresGlobal->maxBaseObject = GetHandleSize( gBaseObjectData) /		sizeof( baseObjectType);			gObjectActionData = GetResource( kObjectActionResType, kObjectActionResID);	if ( gObjectActionData == nil)	{		ShowErrorAny( eQuitErr, kErrorStrID, nil, nil, nil, nil, kReadObjectActionDataError, -1, -1, -1, __FILE__, 2);		return( MEMORY_ERROR);	}	DetachResource( gObjectActionData);	mDataHandleLockAndRegister( gObjectActionData, nil, nil, ResolveObjectActionData, "\pgObjectActionData")	gAresGlobal->maxObjectAction = GetHandleSize( gObjectActionData)		/ sizeof( objectActionType);			gAresGlobal->okToOpenFile = false;		CorrectAllBaseObjectColor();	ResetAllSpaceObjects();	ResetActionQueueData();	return noErr;}