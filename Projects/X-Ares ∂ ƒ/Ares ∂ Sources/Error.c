/*Ares, a tactical space combat game.Copyright (C) 1997, 1999-2001, 2008 Nathan LamontThis program may be used, mofified, and redistributed either under the termsof the GNU General Public License version 2 or the GNU Lesser General PublicLicense version 3. See `LICENSE.md` for details.*//* Error Handling */#ifndef __CONDITIONALMACROS__#include "ConditionalMacros.h"#endif // __CONDITIONALMACROS__#if TARGET_OS_WIN32	#ifndef __QUICKTIMEVR__	#include <QuickTimeVR.h>	#endif	#ifndef __QTUtilities__	#include "QTUtilities.h"	#endif	#ifndef __QTVRUtilities__	#include "QTVRUtilities.h"	#endif	#include <TextUtils.h>	#include <Script.h>	#include <string.h>#endif // TARGET_OS_WIN32#include "Resources.h"#include "Error.h"#include <Palettes.h>#include "Dialog Font.h"#include "Set Font By String.h"#define ERROR_STR_ID	800#define ERROR_ALERT_ID	800//#define	kDebugError	// comment out to not include internal code#ifdef kDebugError#define	kAnyAlertID			806#define	kAnyErrorDialogID	811#else#define	kAnyAlertID			805#define	kAnyErrorDialogID	810#endifextern GDHandle   				theDevice;#define	kContinueButton		1#define	kQuitButton			2void ErrPStringFromCString( unsigned char *, unsigned char *);void ErrConcatenatePString( StringPtr, StringPtr);void ShowErrorNoRecover( int whichError, StringPtr sourceCode, int sourceNum){	Str255	s1, s3;	//	if ( theDevice != nil) RestoreDeviceClut( theDevice);		GetIndString( s1, ERROR_STR_ID, whichError);	if ( sourceCode == nil)		ParamText( s1, nil, nil, nil);	 else	 {	 	NumToString( (long)sourceNum, s3);	 	ParamText( s1, sourceCode, s3, nil);	 }	StopAlert( ERROR_ALERT_ID, nil);	ExitToShell();}void ShowErrorRecover( int whichError, StringPtr sourceCode, int sourceNum){	Str255	s1, s3;//	if ( theDevice != nil) RestoreDeviceClut( theDevice);		GetIndString( s1, ERROR_STR_ID, whichError);	if ( sourceCode == nil)		ParamText( s1, nil, nil, nil);	 else	 {	 	NumToString( (long)sourceNum, s3);	 	ParamText( s1, sourceCode, s3, nil);	 }	StopAlert( ERROR_ALERT_ID, nil);}void ShowSimpleStringAlert( StringPtr string1, StringPtr string2, StringPtr string3, StringPtr string4){//	if ( theDevice != nil) RestoreDeviceClut( theDevice);		ParamText( string1, string2, string3, string4);	StopAlert( 805, nil);}void ShowSimpleStrResAlert( short ResID, short num1, short num2, short num3, short num4){	Str255		s1, s2, s3, s4;	StringPtr	sp1 = nil, sp2 = nil, sp3 = nil, sp4 = nil;		if ( ResID >= 0)	{		if ( num1 > 0)		{			GetIndString( s1, ResID, num1);			sp1 = s1;		}		if ( num2 > 0)		{			GetIndString( s2, ResID, num2);			sp2 = s2;		}		if ( num3 > 0)		{			GetIndString( s3, ResID, num3);			sp3 = s3;		}		if ( num4 > 0)		{			GetIndString( s4, ResID, num4);			sp4 = s4;		}	}	ShowSimpleStringAlert( sp1, sp2, sp3, sp4);}/* template:ShowErrorAny( false, kErrorStrID, nil, nil, nil, nil, -1, -1, -1, -1, __FILE__, 0);*/void ShowErrorAny(	errorRecoverType recover,						short ResID,						StringPtr sp1,						StringPtr sp2,						StringPtr sp3,						StringPtr sp4,						long num1,						long num2,						long num3,						long num4,						char *caller, // pass __FILE__						long callerNum){	Str255			s1, s2, s3, s4;	GrafPtr			oldPort = nil;	DialogPtr		theDialog = nil;	short			itemHit, itemType;	Boolean 		done = false, quit = false;	Rect			itemRect;	Handle			itemHandle;	#pragma unused ( caller, callerNum)	ParamText( "\p", "\p", "\p", "\p");	InitCursor();	FlushEvents(everyEvent, 0);	if ( ResID >= 0)	{		if ( num1 > 0)		{			GetIndString( s1, ResID, num1);			sp1 = s1;		}		if ( num2 > 0)		{			GetIndString( s2, ResID, num2);			sp2 = s2;		}		if ( num3 > 0)		{			GetIndString( s3, ResID, num3);			sp3 = s3;		}		if ( num4 > 0)		{			GetIndString( s4, ResID, num4);			sp4 = s4;		}	}#ifdef kDebugError		ErrPStringFromCString( (unsigned char *)callerString, (unsigned char *)caller);	ErrConcatenatePString( callerString, "\p, #");	NumToString( callerNum, s4);	ErrConcatenatePString( callerString, s4);	sp4 = callerString;#endif//	if ( theDevice != nil) RestoreDeviceClut( theDevice);		ParamText( sp1, sp2, sp3, sp4);//	StopAlert( kAnyAlertID, nil);	GetPort( &oldPort);	theDialog = GetNewDialog( kAnyErrorDialogID, nil, (WindowPtr)-1L);		if ( theDialog == nil) DebugStr("\pNo Error Dialog!");	SetWRefCon( theDialog, (long)kAnyErrorDialogID);	MacSetPort( (GrafPtr)theDialog);	SetDialogFontAndSize( theDialog, GetFontNumByString("\pgeneva"), 10);	if (( recover != eContinueErr) && ( recover != eContinueOnlyErr))	{		SetDialogDefaultItem( theDialog, kQuitButton);		GetDialogItem( theDialog, kContinueButton, &itemType, &itemHandle, &itemRect);//		SetControlTitle( (ControlHandle)itemHandle, "\pDebugger");		HiliteControl( (ControlHandle)itemHandle, 255);	} else	{		if ( recover == eContinueOnlyErr)		{			GetDialogItem( theDialog, kQuitButton, &itemType, &itemHandle, &itemRect);			HiliteControl( (ControlHandle)itemHandle, 255);		}		SetDialogDefaultItem( theDialog, kContinueButton);	}		MacShowWindow( theDialog);		done = false;	while ( done == false)	{		ModalDialog( nil, &itemHit);		switch( itemHit)		{			case kContinueButton:				done = true;				break;						case kQuitButton:				done = true;				quit = true;				break;					}	}	if ( theDialog != nil) DisposeDialog( theDialog);	MacSetPort( oldPort);	if (( recover == eExitToShellErr) || (( recover == eContinueErr) && ( quit)))	{		ExitToShell();	}}/* shows an alert which reads:[string] [error#] occured.where [string] is specified by an indexed string and error # is an error resultcode. Use it to show simple errors like:Couldn’t create the monkey because an error of type -234 occured.template:ShowErrorOfTypeOccurred( false, kErrorStrID, -1, status, __FILE__, 0);*/void ShowErrorOfTypeOccurred( errorRecoverType recover, short resID, short stringNum,	OSErr error, char *caller, long callerNum){	Str255	occurredString, errorString;		GetIndString( occurredString, kErrorStrID, kOccurredError);	NumToString( error, errorString);	ErrConcatenatePString( errorString, occurredString);	ShowErrorAny( recover, resID, nil, errorString, nil, nil, stringNum,		-1, -1, -1, caller, callerNum);}void ErrPStringFromCString( unsigned char *pString, unsigned char *cString){	unsigned char	*len;		len = pString;	pString++;	*len = 0;	while( *cString != '\0')	{		*pString = *cString;		(*len)++;		pString++;		cString++;	}}void ErrConcatenatePString( StringPtr dString, StringPtr sString){	unsigned char	*dc, *sc;	int		i;		dc = dString + (long)*dString + 1L;	sc = sString + 1L;	for ( i = 0; i < *sString; i++)	{		*dc = *sc;		(*dString)++;		dc++;		sc++;	}}void MyDebugString( StringPtr s){#ifdef kDebugError	DebugStr( s);#else	ShowSimpleStringAlert( s, "\p", "\p", "\p");#endif}