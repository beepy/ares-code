<HTML><HEAD><TITLE>GameRanger Library</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><H2><U>Adding Support for GameRanger</U></H2><I>August 27, 1999</I><UL><LI><A HREF="#STARTUPCMD">Receiving the host/join command from GameRanger at startup</A><LI><A HREF="#RESUMECMD">Receiving the host/join command from GameRanger after resuming</A><LI><A HREF="#HOSTING">Hosting</A><LI><A HREF="#JOINING">Joining</A><LI><A HREF="#SCORING">About the Scoring</A><LI><A HREF="#OPENINGGR">Opening GameRanger</A></UL><A HREF="#NSp">NetSprocket Helpers</A><BR><A HREF="#REF">Function Reference</A><P>Use the included <B>GRTest</B> application to test your game's support. <B>Receive Test</B> is asimple application that can be tested with <B>GRTest</B>.<P>If you have any questions or comments or if there is anything you would like to see added, please email me.<BR><B>Scott Kevill</B><BR><B><A HREF="mailto:scott@GameRanger.com">scott@GameRanger.com</A></B><P><HR SIZE="4"><A NAME="STARTUPCMD"></A><H3><U>Receiving the host/join command from GameRanger at startup</U></H3>The first step is receiving the host/join command from GameRanger. This can be passed by eitheran AppleEvent or a temporary file:<UL><LI><B>AppleEvent Command (Game already supports AppleEvents)</B><BR>	In your existing AE handler for OAPP (kAEOpenApplication), call <TT><A HREF="#GRCheckAEForCmd">GRCheckAEForCmd()</A></TT> and if	<TT>true</TT> is returned, call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT> and skip any intro movies and set-up menus to host/join the game.<P>	<LI><B>AppleEvent Command (Game doesn't support AppleEvents)</B><BR>	Set the '<TT>SIZE</TT>' resource flags for your game to be high-level event aware.<BR>	During initialization call <A HREF="#GRInstallStartupHandler"><TT>GRInstallStartupHandler()</TT></A>.<BR>	Then during your startup process, call <TT><A HREF="#GRCheckForAE">GRCheckForAE()</A></TT> and	if <TT>true</TT> is returned, call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT> and skip any intro movies and set-up menus to host/join the game.<P><LI><B>File Command</B><BR>	During your startup process, call	<TT><A HREF="#GRCheckFileForCmd">GRCheckFileForCmd()</A></TT> and if <TT>true</TT> is returned,	call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT> and 	skip any intro movies and set-up menus, and host/join the game.<BR></UL>At any point, these inexpensive calls can be made to determine which parts of menus or intros to skip:<BR><UL><TT><A HREF="#GRIsCmd">GRIsCmd()</A></TT><BR><TT><A HREF="#GRIsHostCmd">GRIsHostCmd()</A></TT><BR><TT><A HREF="#GRIsJoinCmd">GRIsJoinCmd()</A></TT><P></UL><HR><A NAME="RESUMECMD"></A><H3><U>Receiving the host/join command from GameRanger after resuming</U></H3>If your game allows switching out to other applications, you should try to accept host/join commands after resuming.This allows a player to switch back to GameRanger to choose someone new to play against without having to quit andrelaunch the game.<P>This command can be passed by either an AppleEvent or a temporary file:<UL><LI><B>AppleEvent Command (Game already supports AppleEvents)</B><BR>	During initialization call <A HREF="#GRInstallResumeHandler"><TT>GRInstallResumeHandler()</TT></A>.<BR>	After resuming call	<TT><A HREF="#GRCheckForAE">GRCheckForAE()</A></TT> and if <TT>true</TT>	is returned, abort the current game (if any) and any menus, and host/join the game.<P>	<LI><B>AppleEvent Command (Game doesn't support AppleEvents)</B><BR>	Set the '<TT>SIZE</TT>' resource flags for your game to be high-level event aware.<BR>	During initialization call <A HREF="#GRInstallResumeHandler"><TT>GRInstallResumeHandler()</TT></A>.<BR>	After resuming call	<TT><A HREF="#GRCheckForAE">GRCheckForAE()</A></TT> and if <TT>true</TT>	is returned, abort the current game (if any) and any menus, and host/join the game.<P><LI><B>File Command</B><BR>	After resuming call	<TT><A HREF="#GRCheckFileForCmd">GRCheckFileForCmd()</A></TT> and if <TT>true</TT> is returned,	abort the current game (if any) and any menus, and host/join the game.</UL>If there was a game in progress already, do not call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT>immediately. During the abort process you will still need the information about the current command(eg. <TT><A HREF="#GRIsHostCmd">GRIsHostCmd()</A></TT> to determine if you need to call<TT><A HREF="#GRHostClosed">GRHostClosed()</A></TT>). Once the aborting is complete(and perhaps returned to the main menu) the code can call <TT><A HREF="#GRIsWaitingCmd">GRIsWaitingCmd()</A></TT>and then <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT> to continue starting a new game.<P>If there was not a game in progress, then you can just call <TT><A HREF="#GRGetWaitingCmd">GRGetWaitingCmd()</A></TT>and start the new game.<P><HR><A NAME="HOSTING"></A><H3><U>Hosting</U></H3>Begin a game with these optional calls to specify settings:<BR><UL><TT><A HREF="#GRGetPlayerName">GRGetPlayerName()</A></TT><BR><TT><A HREF="#GRGetHostGameName">GRGetHostGameName()</A></TT><BR><TT><A HREF="#GRGetHostMaxPlayers">GRGetHostMaxPlayers()</A></TT><BR><TT><A HREF="#GRGetPortNumber">GRGetPortNumber()</A></TT><BR>(If you are using NetSprocket then there are <A HREF="#NSp">helpers</A> to make this part even easier.)<P></UL>When ready to accept connections from clients, call<BR><UL><TT><A HREF="#GRHostReady">GRHostReady()</A></TT><BR></UL>At this stage, the game may have it's own pre-game lounge where various options are set by all players,otherwise the following <TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT> would be called immediately.<P>When the player is actually in the game and game play has started, call<UL><TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT><BR></UL>At the end of the game, report the scores by calling<UL><TT><A HREF="#GRStatScore">GRStatScore()</A></TT> (for this player) and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT> (once for each other player)<BR></UL>And then call<UL><TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT><BR></UL>If there are multiple rounds, call the<TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT> ...<TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT> sequence for each round. For example, in Quake, each level played would be a round.<P>When the game has completely ended, call<BR><UL><TT><A HREF="#GRHostClosed">GRHostClosed()</A></TT></UL><B>Summary</B><BR><UL><TT><A HREF="#GRHostReady">GRHostReady()</A></TT><BR><UL><TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT><BR>. . . game play . . .<BR><TT><A HREF="#GRStatScore">GRStatScore()</A></TT><BR><TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT><BR><TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT><BR>. . . repeat above loop for any further rounds . . .<BR></UL><TT><A HREF="#GRHostClosed">GRHostClosed()</A></TT><BR>. . . optionally return to GameRanger via switching or quitting . . .<BR></UL><HR><A NAME="JOINING"></A><H3><U>Joining</U></H3>Begin a game with these calls to specify settings:<BR><UL><TT><A HREF="#GRGetJoinAddress">GRGetJoinAddress()</A></TT> (<B>required</B>)<BR><TT><A HREF="#GRGetPlayerName">GRGetPlayerName()</A></TT> (optional)<BR><TT><A HREF="#GRGetPortNumber">GRGetPortNumber()</A></TT> (optional)<BR>(If you are using NetSprocket then there are <A HREF="#NSp">helpers</A> to make this part even easier.)</UL>When the player is actually in the game and game play has started, call<UL><TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT><BR></UL>At the end of the game, report the scores by calling<UL><TT><A HREF="#GRStatScore">GRStatScore()</A></TT> (for this player) and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT> (once for each other player)<BR></UL>And then call<UL><TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT><BR></UL>If there are multiple rounds, call the<TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT> ...<TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT> sequence for each round. For example, in Quake, each level played would be a round.<P>Finally, call <TT><A HREF="#GRReset">GRReset()</A></TT> to clear that GameRanger command.<P><B>Summary</B><BR><UL><TT><A HREF="#GRGameBegin">GRGameBegin()</A></TT><BR>. . . game play . . .<BR><TT><A HREF="#GRStatScore">GRStatScore()</A></TT><BR><TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT><BR><TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT><BR>. . . repeat above loop for any further rounds . . .<BR><TT><A HREF="#GRReset">GRReset()</A></TT><BR>. . . optionally return to GameRanger via switching or quitting . . .<BR></UL><HR><A NAME="SCORING"></A><H3><U>About the Scoring</U></H3>The <TT><A HREF="#GRStatScore">GRStatScore()</A></TT> and <TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT>calls may seem a little confusing at first.<P>They are there to allow the game to automatically report scores for when ladders, rankings and tournaments are addedto GameRanger in the future.<P>Right before calling <TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT>, every player's game calls<TT><A HREF="#GRStatScore">GRStatScore()</A></TT> with their <B>own</B> score. Additionally, each player also calls<TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT> one time for each <B>other</B> player's score (order isnot important). This serves as a simple cheat check to make sure all games agree on the scores.<P>If a player leaves the game early, the other players don't need to remember that player. Instead they just call<TT><A HREF="#GRStatOtherScore">GRStatOtherScore()</A></TT> at the time the player leaves (assuming the missingplayer won't be counted again at the end). The player that leaves early should only report their own score (plusthe scores of any previous players that left that they would have reported). The simple way of describing this is,a player should have reported only the scores that it knows were <B>final</B>.<P>If the game doesn't use a numerical score, but instead is more of a win vs loss, simply use <B>1</B> for<B>win</B> and <B>0</B> for <B>loss</B>. In the event of a tie or stalemate situation, both scores could be<B>1</B> or both scores could be <B>0</B>.<P><HR><A NAME="OPENINGGR"></A><H3><U>Opening GameRanger</U></H3>If you want to provide a button or menu command for launching or switching to GameRanger, call<BR><UL><TT><A HREF="#GROpenGameRanger">GROpenGameRanger()</A></TT><BR></UL>If you have just responded to a command from GameRanger, it should already be running, and thiscall can be used to switch back to it.<P>A convenience for players would be to switch back to GameRangerautomatically after the game play has finished when the game was initiated from GameRanger. If thegame doesn't support switching out to other apps, the player would benefit from the game quittingat this point (also returning them to GameRanger).<P>Common return values for failure would be <TT>fnfErr</TT> (-43), and <TT>memFullErr</TT> (-108) if theGameRanger application cannot be found, or there is not enough memory to launch it.<P><HR><A NAME="NSp"></A><H3><U>NetSprocket Helpers</U></H3>Simply replace <TT>NSpDoModalHostDialog</TT> with <A HREF="#GRNSpDoModalHostDialog"><TT>GRNSpDoModalHostDialog</TT></A> and<TT>NSpDoModalJoinDialog</TT> with <A HREF="#GRNSpDoModalJoinDialog"><TT>GRNSpDoModalJoinDialog</TT></A>.<P>When a GameRanger command is in progress, the dialogs will be skipped and the parameters filled in from GameRanger, otherwisethey will call through to the normal NetSprocket routines.<P>You will also need to replace <TT>NSpReleaseAddressReference</TT> with<A HREF="#GRNSpReleaseAddressReference"><TT>GRNSpReleaseAddressReference</TT></A>. This will correctly dispose ofan address reference in all cases.<P><HR><A NAME="REF"></A><H3><U>Function Reference</U></H3><DL><DT><A NAME="GRInstallStartupHandler"><B><TT>OSErr GRInstallStartupHandler(void)</TT></B></A></DT><DD>Call this during initialization if your game does not already handle AppleEvents but you do want the command accepted as one.<P></DD><DT><A NAME="GRInstallResumeHandler"><B><TT>OSErr GRInstallResumeHandler(void)</TT></B></A></DT><DD>Call this during initialization if your game allows switching out and you do want the command accepted as an AppleEvent.Your game does not need to already have AppleEvent support.<P></DD><DT><A NAME="GRCheckAEForCmd"><B><TT>Boolean GRCheckAEForCmd(const AppleEvent *theEvent)</TT></B></A></DT><DD>Call this in your OAPP (kAEOpenApplication) AppleEvent handler if your game already supports AppleEvents.<BR>Returns <TT>true</TT> if a command was accepted.<P></DD><DT><A NAME="GRCheckFileForCmd"><B><TT>Boolean GRCheckFileForCmd(void)</TT></B></A></DT><DD>Call this during startup and when resuming (if your game allows switching out) to check for a command in a temporary file.<BR>Returns <TT>true</TT> if a command was accepted.<P></DD><DT><A NAME="GRCheckForAE"><B><TT>Boolean GRCheckForAE(void)</TT></B></A></DT><DD>Call this during startup and when resuming (if your game allows switching out) to check for an AppleEvent command.If your game already supports AppleEvents, then do not call this at startup (startup commands will be accepted with <TT><A HREF="#GRCheckAEForCmd">GRCheckAEForCmd()</A></TT> in an existing handler of yours).<BR>Returns <TT>true</TT> if a command was accepted.<P></DD><DT><A NAME="GRIsWaitingCmd"><B><TT>Boolean GRIsWaitingCmd(void)</TT></B></A></DT><DD>Call this at any point to tell if a command is waiting to be acted upon. You may want to use this at the end ofaborting the current game to determine if a new game should be started in its place.<BR><P></DD><DT><A NAME="GRGetWaitingCmd"><B><TT>void GRGetWaitingCmd(void)</TT></B></A></DT><DD>Sets the waiting command to be the current command, and then clears the waiting command.<P></DD><DT><A NAME="GRIsCmd"><B><TT>Boolean GRIsCmd(void)</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>host or join</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRIsHostCmd"><B><TT>Boolean GRIsHostCmd(void)</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>host</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRIsJoinCmd"><B><TT>Boolean GRIsJoinCmd(void)</TT></B></A></DT><DD>This can be called at any point and can be used to decide the path to follow or whether intros or menus should be skipped.<BR>Returns <TT>true</TT> if a <B>join</B> command is in progress (ie. the current command).<P></DD><DT><A NAME="GRGetPlayerName"><B><TT>char* GRGetPlayerName(void)</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns a pointer to the player name (C string). Remember to check the length and truncate if necessary.<P></DD><DT><A NAME="GRGetPortNumber"><B><TT>UInt16 GRGetPortNumber(void)</TT></B></A></DT><DD><B>Host and join parameter</B>. Returns the port number to host the game on, or to connect to when joining. Ignore this if not applicable, or if the value is zero (0).<P></DD><DT><A NAME="GRGetHostGameName"><B><TT>char* GRGetHostGameName(void)</TT></B></A></DT><DD><B>Host parameter</B>. Returns a pointer to the game name (C string). Remember to check the length and truncate if necessary.<P></DD><DT><A NAME="GRGetHostMaxPlayers"><B><TT>UInt16 GRGetHostMaxPlayers(void)</TT></B></A></DT><DD><B>Host parameter</B>. Returns the maximum number of players to host the game for (includes the host).<P></DD><DT><A NAME="GRGetJoinAddress"><B><TT>UInt32 GRGetJoinAddress(void)</TT></B></A></DT><DD><B>Join parameter</B>. Returns the IP address of the host to join. Address is a 32 bit IP address in network order (big endian).<P></DD><DT><A NAME="GRReset"><B><TT>void GRReset(void)</TT></B></A></DT><DD>Clears the current GameRanger command. Call this after a completed game that was joined.It's not necessary if the game was hosted, as <TT><A HREF="#GRHostClosed">GRHostClosed()</A></TT> calls this anyway,but it harmless to be called more than once.<P></DD><DT><A NAME="GRHostReady"><B><TT>void GRHostReady(void)</TT></B></A></DT><DD>Call this when hosting and ready to accept connections. This will trigger the other clients in the game room to join.This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRGameBegin"><B><TT>void GRGameBegin(void)</TT></B></A></DT><DD>Call this once the game play has started for this player. This is mainly to begin the scoring. For example, Quake wouldcall this after joining a game and after each level change. With other games where a "join" puts them into a lobby, thiswould be called only when the game actually begins. Should be balanced with a call to<TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT>. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRStatScore"><B><TT>void GRStatScore(SInt32 score)</TT></B></A></DT><DD>Call this at the end of the game (before calling <TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT>) with the finalscore of this player. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRStatOtherScore"><B><TT>void GRStatOtherScore(SInt32 score)</TT></B></A></DT><DD>Call this at the end of the game (before calling <TT><A HREF="#GRGameEnd">GRGameEnd()</A></TT>) with the final scores of all<B>other</B> players. This enables GameRanger to do a simple check to help detect another client cheating.This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRGameEnd"><B><TT>void GRGameEnd(void)</TT></B></A></DT><DD>Call this when the currently playing game has ended and scores are reported. This might only be temporary as is thecase with Quake changing levels. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GRHostClosed"><B><TT>void GRHostClosed(void)</TT></B></A></DT><DD>Call this on the host when the game has completely ended. In the GameRanger application, the game will no longerbe flagged as in-progress. This call will do nothing if the current game was not a GameRanger game.<P></DD><DT><A NAME="GROpenGameRanger"><B><TT>OSErr GROpenGameRanger(void)</TT></B></A></DT><DD>Call this if you want to provide a button or menu command for launching or switching to GameRanger.<BR>Common return values for failure would be <TT>fnfErr</TT> (-43), and <TT>memFullErr</TT> (-108) if theGameRanger application cannot be found, or there is not enough memory to launch it.<P></DD><DT><PRE><A NAME="GRNSpDoModalHostDialog"></A><B>BooleanGRNSpDoModalHostDialog(NSpProtocolListReference  ioProtocolList,                       Str31                     ioGameName,                       Str31                     ioPlayerName,                       Str31                     ioPassword,                       NSpEventProcPtr           inEventProcPtr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpDoModalHostDialog</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD><DT><PRE><A NAME="GRNSpDoModalJoinDialog"></A><B>NSpAddressReferenceGRNSpDoModalJoinDialog(ConstStr31Param           inGameType,                       ConstStr255Param          inEntityListLabel,                       Str31                     ioName,                       Str31                     ioPassword,                       NSpEventProcPtr           inEventProcPtr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpDoModalJoinDialog</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD><DT><PRE><A NAME="GRNSpReleaseAddressReference"></A><B>voidGRNSpReleaseAddressReference(NSpAddressReference inAddr)</B></PRE></DT><DD>Call this <B>instead</B> of <TT>NSpReleaseAddressReference</TT> in a NetSprocket-based game. This will do the right thingand call through to the original NetSprocket routine if a GameRanger command is not currently in progress.<P></DD></DL></BODY></HTML>