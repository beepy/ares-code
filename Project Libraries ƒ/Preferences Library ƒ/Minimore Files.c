#include <ConditionalMacros.h>#include <Types.h>#include <LowMem.h>#include <Gestalt.h>	// changed by NL 6/2/97#include <Resources.h>#include <Script.h>#include "Minimore Files.h"enum {	gestaltBugFixAttrsTwo					= 'bugy',	gestaltFSpExchangeFilesCompatibilityFix	= 26,	gestaltBugFixAttrsThree					= 'bugx',	gestaltFSpCreateScriptSupportFix		= 1};/*****************************************************************************//* local data structures *//* The DeleteEnumGlobals structure is used to minimize the amount of** stack space used when recursively calling DeleteLevel and to hold** global information that might be needed at any time. */struct DeleteEnumGlobals{	OSErr			error;				/* temporary holder of results - saves 2 bytes of stack each level */	Str63			itemName;			/* the name of the current item */	UniversalFMPB	myPB;				/* the parameter block used for PBGetCatInfo calls */};typedef struct DeleteEnumGlobals DeleteEnumGlobals;typedef DeleteEnumGlobals *DeleteEnumGlobalsPtr;/* static prototypes */static	void	pcpy(StringPtr d,					 StringPtr s);					 static	Boolean	FSHasFSSpecCalls(void);static	Boolean	QTHasFSSpecCalls(void);static	Boolean	HasFSpExchangeFilesCompatibilityFix(void);static	Boolean	HasFSpCreateScriptSupportFix(void);static	OSErr	GenerateUniqueName(short volume,								   long *startSeed,								   long dir1,								   long dir2,								   StringPtr uniqueName);static	Ptr	GetSearchBuffer(long *);static	void	DeleteLevel(long, DeleteEnumGlobalsPtr);static	void	pcpy(StringPtr d,					 StringPtr s){	short	i;	i = *s;	do {		d[i] = s[i];	} while (i--);}/*****************************************************************************//* FSHasFSSpecCalls returns true if the file system provides FSSpec calls. */static	Boolean	FSHasFSSpecCalls(void){	long			response;	static Boolean	tested = false;	static Boolean	result = false;		if (!tested)	{		tested = true;		if (Gestalt(gestaltFSAttr, &response) == noErr)		{			result = ((response & (1L << gestaltHasFSSpecCalls)) != 0);		}	}	return (result);}/*****************************************************************************//* QTHasFSSpecCalls returns true if QuickTime provides FSSpec calls *//* except for FSpExchangeFiles. */static	Boolean	QTHasFSSpecCalls(void){	long			response;	static Boolean	tested = false;	static Boolean	result = false;		if (!tested)	{		tested = true;		result = (Gestalt(gestaltQuickTime, &response) == noErr);	}	return (result);}/*****************************************************************************//* HasFSpExchangeFilesCompatibilityFix returns true if FSpExchangeFiles *//* compatibility code has been fixed in system software. */Boolean	HasFSpExchangeFilesCompatibilityFix(void){	long			response;	static Boolean	tested = false;	static Boolean	result = false;		if (!tested)	{		tested = true;		if (Gestalt(gestaltBugFixAttrsTwo, &response) == noErr)		{			result = ((response & (1L << gestaltFSpExchangeFilesCompatibilityFix)) != 0);		}	}	return (result);}/*****************************************************************************//* HasFSpCreateScriptSupportFix returns true if FSpCreate and *//* FSpCreateResFile have been fixed in system software to correctly set *//* the scriptCode in the volume's catalog. */Boolean	HasFSpCreateScriptSupportFix(void){	long			response;	static Boolean	tested = false;	static Boolean	result = false;		if (!tested)	{		if (Gestalt(gestaltBugFixAttrsThree, &response) == noErr)		{			result = ((response & (1L << gestaltFSpCreateScriptSupportFix)) != 0);		}	}	return (result);}pascal	short	FSpOpenResFileCompat(const FSSpec *spec,									 SignedByte permission){	/* еееее NEED TO MAKE SURE QUICKTIME PROVIDES THIS ONE еееее */	if (FSHasFSSpecCalls() || QTHasFSSpecCalls())		return (FSpOpenResFile(spec, permission));	else		return (HOpenResFile(spec->vRefNum, spec->parID, spec->name, permission));}/*****************************************************************************/pascal	OSErr	FSpDeleteCompat(const FSSpec *spec){	HParamBlockRec	pb;	if (FSHasFSSpecCalls() || QTHasFSSpecCalls())		return (FSpDelete(spec));	else	{		pb.ioParam.ioVRefNum = spec->vRefNum;		pb.fileParam.ioDirID = spec->parID;		pb.ioParam.ioNamePtr = (StringPtr) &(spec->name);		pb.ioParam.ioVersNum = 0;		return (PBHDeleteSync(&pb));	}}pascal	OSErr	DeleteDirectory(short vRefNum,								long dirID,								StringPtr name){	OSErr error;		/* Make sure a directory was specified and then delete its contents */	error = DeleteDirectoryContents(vRefNum, dirID, name);	if (error == noErr)	{		error = HDelete(vRefNum, dirID, name);		if (error == fLckdErr)		{			(void) HRstFLock(vRefNum, dirID, name);	/* unlock the directory locked by AppleShare */			error = HDelete(vRefNum, dirID, name);	/* and try again */		}	}	return (error);}pascal	OSErr	CreatorTypeFileSearch(StringPtr volName,									  short vRefNum,									  OSType creator,									  OSType fileType,									  FSSpecPtr matches,									  long reqMatchCount,									  long *actMatchCount,									  Boolean newSearch){	CInfoPBRec		searchInfo1, searchInfo2;	HParamBlockRec	pb;	OSErr			error;	static CatPositionRec catPosition;	static short	lastVRefNum = 0;		/* get the real volume reference number */	error = DetermineVRefNum(volName, vRefNum, &vRefNum);	if (error != noErr)		return (error);		pb.csParam.ioNamePtr = nil;	pb.csParam.ioVRefNum = vRefNum;	pb.csParam.ioMatchPtr = matches;	pb.csParam.ioReqMatchCount = reqMatchCount;	pb.csParam.ioSearchBits = fsSBFlAttrib + fsSBFlFndrInfo;	/* Looking for finder info file matches */	pb.csParam.ioSearchInfo1 = &searchInfo1;	pb.csParam.ioSearchInfo2 = &searchInfo2;	pb.csParam.ioSearchTime = 0;	if ((newSearch) ||				/* If caller specified new search */		(lastVRefNum != vRefNum))	/* or if last search was to another volume, */		catPosition.initialize = 0;	/* then search from beginning of catalog */	pb.csParam.ioCatPosition = catPosition;	pb.csParam.ioOptBuffer = GetSearchBuffer(&pb.csParam.ioOptBufSize);	/* no fileName */	searchInfo1.hFileInfo.ioNamePtr = nil;	searchInfo2.hFileInfo.ioNamePtr = nil;		/* only match files (not directories) */	searchInfo1.hFileInfo.ioFlAttrib = 0x00;	searchInfo2.hFileInfo.ioFlAttrib = 0x10;		/* search for creator; if creator = 0x00000000, ignore creator */	searchInfo1.hFileInfo.ioFlFndrInfo.fdCreator = creator;	searchInfo2.hFileInfo.ioFlFndrInfo.fdCreator = (creator == (OSType)0x00000000) ?		(OSType)0x00000000 :		(OSType)0xffffffff;		/* search for fileType; if fileType = 0x00000000, ignore fileType */	searchInfo1.hFileInfo.ioFlFndrInfo.fdType = fileType;	searchInfo2.hFileInfo.ioFlFndrInfo.fdType = (fileType == (OSType)0x00000000) ?		(OSType)0x00000000 :		(OSType)0xffffffff;		/* zero all other FInfo fields */	searchInfo1.hFileInfo.ioFlFndrInfo.fdFlags = 0;	searchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.v = 0;	searchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.h = 0;	searchInfo1.hFileInfo.ioFlFndrInfo.fdFldr = 0;		searchInfo2.hFileInfo.ioFlFndrInfo.fdFlags = 0;	searchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.v = 0;	searchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.h = 0;	searchInfo2.hFileInfo.ioFlFndrInfo.fdFldr = 0;	error = PBCatSearchSync((CSParamPtr)&pb);		if ((error == noErr) ||							/* If no errors or the end of catalog was */		(error == eofErr))							/* found, then the call was successful so */		*actMatchCount = pb.csParam.ioActMatchCount;	/* return the match count */	else		*actMatchCount = 0;							/* else no matches found */		if ((error == noErr) ||							/* If no errors */		(error == catChangedErr))					/* or there was a change in the catalog */	{		catPosition = pb.csParam.ioCatPosition;		lastVRefNum = vRefNum;			/* we can probably start the next search where we stopped this time */	}	else		catPosition.initialize = 0;			/* start the next search from beginning of catalog */		if (pb.csParam.ioOptBuffer)		DisposPtr(pb.csParam.ioOptBuffer);			return (error);}/* A utility routine called by NameFileSearch and CreatorTypeFileSearch to** allocate a optimization buffer. */static	Ptr	GetSearchBuffer(long *buffSize){	Ptr	tempPtr;		*buffSize = 0x00004000;	/* start by trying for a 16K buffer */	while (*buffSize) {		/* and keep trying until *buffSize is zero */		tempPtr = NewPtr(*buffSize);		if (tempPtr)			break;	/* got it */		else			*buffSize -= 0x00000400;	/* didn't get it, subtract 1K and try again */	}	return (tempPtr);}pascal	OSErr	DeleteDirectoryContents(short vRefNum,								 		long dirID,										StringPtr name){	DeleteEnumGlobals theGlobals;	Boolean	isDirectory;	OSErr error;	/*  Get the real dirID and make sure it is a directory. */	error = GetDirID(vRefNum, dirID, name, &dirID, &isDirectory);	if (error != noErr)		return (error);	if (!isDirectory)		return (dirNFErr);		/* Get the real vRefNum */	error = DetermineVRefNum(name, vRefNum, &vRefNum);	if (error != noErr)		return (error);		/* Set up the globals we need to access from the recursive routine. */	theGlobals.myPB.ciPB.dirInfo.ioVRefNum = vRefNum;			/* Here we go into recursion land... */	DeleteLevel(dirID, &theGlobals);	return (theGlobals.error);}static	void	DeleteLevel(long dirToDelete,							DeleteEnumGlobalsPtr theGlobals){	long savedDir;		do	{		/* prepare to delete directory */		theGlobals->myPB.ciPB.dirInfo.ioNamePtr = (StringPtr)&theGlobals->itemName;		theGlobals->myPB.ciPB.dirInfo.ioFDirIndex = 1;	/* get first item */		theGlobals->myPB.ciPB.dirInfo.ioDrDirID = dirToDelete;	/* in this directory */		theGlobals->error = PBGetCatInfoSync(&(theGlobals->myPB.ciPB));		if (theGlobals->error == noErr)		{			savedDir = dirToDelete;			/* We have an item.  Is it a file or directory? */			if ((theGlobals->myPB.ciPB.dirInfo.ioFlAttrib & 0x10) != 0)			{				/* it's a directory */				savedDir = theGlobals->myPB.ciPB.dirInfo.ioDrDirID;	/* save dirID of directory instead */				DeleteLevel(theGlobals->myPB.ciPB.dirInfo.ioDrDirID, theGlobals);	/* Delete its contents */				theGlobals->myPB.ciPB.dirInfo.ioNamePtr = nil;	/* prepare to delete directory */			}			if (theGlobals->error == noErr)			{				theGlobals->myPB.ciPB.dirInfo.ioDrDirID = savedDir;	/* restore dirID */				theGlobals->error = PBHDeleteSync(&(theGlobals->myPB.hPB));	/* delete this item */				if (theGlobals->error == fLckdErr)				{					(void) PBHRstFLockSync(&(theGlobals->myPB.hPB));	/* unlock it */					theGlobals->error = PBHDeleteSync(&(theGlobals->myPB.hPB));	/* and try again */				}			}		}	}	while (theGlobals->error == noErr);	if (theGlobals->error == fnfErr)		theGlobals->error = noErr;}pascal	OSErr	DetermineVRefNum(StringPtr pathname,								 short vRefNum,								 short *realVRefNum){	HParamBlockRec pb;	Str255 tempPathname;	OSErr error;	pb.volumeParam.ioVRefNum = vRefNum;	if (pathname == nil) {		pb.volumeParam.ioNamePtr = nil;		pb.volumeParam.ioVolIndex = 0;		/* use ioVRefNum only */	}	else {		pcpy((StringPtr)tempPathname, pathname);	/* make a copy of the string and */		pb.volumeParam.ioNamePtr = (StringPtr)tempPathname;	/* use the copy so original isn't trashed */		pb.volumeParam.ioVolIndex = -1;	/* use ioNamePtr/ioVRefNum combination */	}	error = PBHGetVInfoSync(&pb);	*realVRefNum = pb.volumeParam.ioVRefNum;	return (error);}pascal	OSErr	GetDirID(short vRefNum,						 long dirID,						 StringPtr name,						 long *theDirID,						 Boolean *isDirectory){	CInfoPBRec pb;	OSErr error;	pb.hFileInfo.ioNamePtr = name;	pb.hFileInfo.ioVRefNum = vRefNum;	pb.hFileInfo.ioDirID = dirID;	pb.hFileInfo.ioFDirIndex = 0;	/* use ioNamePtr and ioDirID */	error = PBGetCatInfoSync(&pb);	*theDirID = pb.hFileInfo.ioDirID;	*isDirectory = (pb.hFileInfo.ioFlAttrib & 0x10) != 0;	return (error);}