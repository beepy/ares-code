// String Numerics.c#ifndef __CONDITIONALMACROS__#include "ConditionalMacros.h"#endif // __CONDITIONALMACROS__#if TARGET_OS_WIN32	#ifndef __QTML__	#include <QTML.h>	#endif	#include <NumberFormatting.h>#endif#include "String Handling.h"#include "String Numerics.h"void SmallFixedToString( smallFixedType f, Str255 s){	short				charnum = 0;	long				l;	Str255			tstring;	smallFixedType	tf;	float				tfloat;		s[0] = 0;	if ( f < 0)	{		charnum++;		s[0] = charnum;		s[charnum] = '-';		f = -f;	}	l = mFixedToLong( f);	NumToString( l, tstring);	ConcatenatePString( (unsigned char *)s, (unsigned char *)tstring);	charnum = s[0] + 1;	s[0] = charnum;	s[charnum] = '.';		tf = mLongToFixed( l);	tf = f - tf;	tfloat = (float)tf;	tfloat /= (float)256;	tfloat += .005;		tfloat *= 100;		l = (long)tfloat;	if ( l < 10)	{		charnum++;		s[0] = charnum;		s[charnum] = '0';	}	NumToString( l, tstring);	ConcatenatePString( (unsigned char *)s, (unsigned char *)tstring);}smallFixedType StringToSmallFixed( Str255 s){	short			charnum = 1;	Boolean		negative = FALSE, seenDecimal = FALSE;	float			value = 0, divider = 0, tfloat;		while (( charnum <= s[0]) && (( s[charnum] < '0') || ( s[charnum] > '9')) &&			(( s[charnum] != '-') && ( s[charnum] != '.')))	{		charnum++;	}		if (( s[charnum] == '-') && ( charnum <= s[0]))	{		negative = TRUE;		charnum++;		while (( charnum <= s[0]) && (( s[charnum] < '0') || ( s[charnum] > '9')))		{			charnum++;		}	}		while ( charnum <= s[0])	{		if (( s[charnum] < '0') || ( s[charnum] > '9'))		{			if ( s[charnum] == '.')			{				if ( !seenDecimal)				{					seenDecimal = TRUE;					divider = 10;				}			}		} else		{			if ( !seenDecimal)			{				value *= (float)10;				value += (float)(s[charnum] - '0');			} else			{				tfloat = s[charnum] - '0';				tfloat /= divider;				value += tfloat;//				value += (float)(s[charnum] - '0') / divider;				divider *= (float)10;			}		}		charnum++;	}	if ( negative) value = -value;	return( mFloatToFixed( value));}void NumToHexString( unsigned long l, Str255 s, long bytenum){	unsigned char	*strlen, *c;	unsigned long	calc;		strlen = s;	c = strlen + 1;	*strlen = 0;	bytenum *= 8;	// 8 bits per byte	do	{		bytenum -= 4;		calc = l;		calc >>= bytenum;		calc &= 0x0000000f;		(*strlen)++;		if ( calc < 10) *c = '0' + calc;		else if ( calc < 16) *c = 'A' + (calc - 10);		else *c = '#';		c++;	} while ( bytenum > 0);}void HexStringToNum( Str255 s, unsigned long *l){	long				strlen;	unsigned char	*c;		c = s;	strlen = *c;	*l = 0;	c++;	while ( strlen > 0)	{		if (( *c >= '0') && ( *c <= '9'))		{			*l += *c - '0';		} else if (( *c >= 'a') && ( *c <= 'f'))		{			*l += *c - 'a' + 10;		} else		{			*l += *c - 'A' + 10;		}		strlen--;		c++;		if ( strlen > 0) *l <<= (long)4;	}}void UnsignedLongToString( unsigned long l, StringPtr s){	unsigned long	tenFactor = 1000000000, t;	// 4 294 967 295 is max unsigned long		while ((( l % tenFactor) == 0) && ( tenFactor > 0)) tenFactor /= 10;	if ( tenFactor == 0)	{		s[0] = 1;		s[1] = '0';		return;	}		s[0] = 0;	do	{		s[0]++;		t = l / tenFactor;		s[s[0]] = '0' + t;		l -= t * tenFactor;		tenFactor /= 10;	} while ( tenFactor > 0);}unsigned long StringToUnsignedLong( StringPtr s){	unsigned long	result = 0;	long				charNum = 1, strLen = s[0];		while ( charNum <= strLen)	{		if ((s[charNum] >= '0') && ( s[charNum] <= '9'))		{			result *= 10;			result += s[charNum] - '0';		}		charNum++;	}	return( result);}