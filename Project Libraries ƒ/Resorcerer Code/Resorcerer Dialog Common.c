// Resorcerer Dialog Common Code// stuck in here by NL// Resorcerer Dialog Common.c#include <TextUtils.h>#ifndef __CONDITIONALMACROS__#include "ConditionalMacros.h"#endif // __CONDITIONALMACROS__#if TARGET_OS_WIN32	#ifndef __QUICKTIMEVR__	#include <QuickTimeVR.h>	#endif	#ifndef __QTUtilities__	#include "QTUtilities.h"	#endif	#ifndef __QTVRUtilities__	#include "QTVRUtilities.h"	#endif	#include <TextUtils.h>	#include <Script.h>	#include <string.h>#endif // TARGET_OS_WIN32#include "Resources.h"#include <DiskInit.h>#include <Dialogs.h>#include <Files.h>#include <Fonts.h>#include <Lists.h>#include <Menus.h>#include <Resources.h>//#include <Memory.h>#include <OSUtils.h>#include <Packages.h>#include <Scrap.h>#include <Script.h>#include <SegLoad.h>#include <StdArg.h>#include <stdio.h>#include <ToolUtils.h>#include <Devices.h>#include <Events.h>#include "Resorcerer Dialog Common.h"#include "Debug.h"/*본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본본*//* *  The following are various utility routines for general dialog management. *  Typically, you'll want to keep them in a library that is available to all *  your dialog modules; however, they are included here (and declared static) *  as a private library so that you can quickly compile this file for testing. */#define _PrivateLibraries_#ifdef  _PrivateLibraries_/* *	Center a given window, w, horizontally in the main screen, top pixels from *	the top, or centered vertically if top is 0.  The window should be invisible. */void CenterWindow(WindowPtr w, short top)	{		Rect scr; Point p;		short rsize,size,margin;		scr = qd.screenBits.bounds;		MacSetPort(w);		p.h = w->portRect.left; p.v = w->portRect.top;		LocalToGlobal(&p);		size = scr.right - scr.left;		rsize = w->portRect.right - w->portRect.left;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.h = scr.left + margin;			}		size = scr.bottom - scr.top;		rsize = w->portRect.bottom - w->portRect.top;		margin = size - rsize;		if (margin > 0) {			margin >>= 1;			p.v = scr.top + margin;			}		MacMoveWindow(w,p.h,top?top:p.v,false);	}/* Local C string length routine */long resorcererstrlen(register char *str)	{		register char *p;		p = str;		while (*p++) ;		return((long)(--p - str));	}/* Convert in place a Pascal string to C string, and deliver its address */char *PascalToC(unsigned char *str)	{		register unsigned char *p,*q,*end;		end = str + *str;		q = (p=str) + 1;		while (p < end) *p++ = *q++;		*p = '\0';		return((char *)str);	}/* *	Convert in place a C string to Pascal string, and deliver its address. *	The C string should not be greater than 255 chars in length, or the *	resulting Pascal string will be truncated to 255 chars. */unsigned char *CToPascal(char *str)	{		register char *p,*q;		register long len;		len = resorcererstrlen(str);		if (len > 255) len = 255;		p = str + len;		q = p-1;		while (p != str) *p-- = *q--;		*str = len;		return((unsigned char *)str);	}/* Dialog Item Stuffers *//* *	Install a given Pascal string, str, into the given static or edit text item *	in the dialog, dlog.  If the item is an edit text item, leave the installed *	text selected or not according to the value of sel (true or false). */void PutDlgString(DialogPtr dlog, int item, unsigned char *str, int sel)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		if ( str != nil)	// NRL			SetDialogItemText(hndl,str);		if ((type == editText) && ( sel))			SelectDialogItemText(dlog,item,sel?0:32767,32767);		InvalRect(&box);	}/* *	Install a given decimal long value into the static or edit text item of the *	given dialog, dlog.  If the item is an edit text item, leave the installed *	text for the number selected or not according to sel (true or false). */void PutDlgLong(DialogPtr dlog, int item, long val, int sel)	{		unsigned char str[32];		NumToString(val,str);		PutDlgString(dlog,item,str,sel);	}/* *	Same as above, only for an int (word) decimal number. */void PutDlgWord(DialogPtr dlog, int item, int val, int sel)	{		PutDlgLong(dlog,item,(long)val,sel);	}/* *	Set the given check box or radio button item of the given dialog, dlog, to *	on or off, according to val. */void PutDlgChkRadio(DialogPtr dlog, int item, int val)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		SetControlValue((ControlHandle)hndl,val!=0);	}/* *	Deliver the value of the checkbox or radio button item of the given dialog. */int GetDlgChkRadio(DialogPtr dlog, int item)	{		short type; Handle hndl; Rect box;				GetDialogItem(dlog,item,&type,&hndl,&box);		return(GetControlValue((ControlHandle)hndl) != 0);	}/* Dialog Item Unstuffers *//* *	Retrieve the value of an edit text item in a given dialog, placing the *	resulting Pascal string in the buffer, str, which is assumed large enough *	to hold the text (256 bytes max).  If item is the number of a static text *	item, the empty string is delivered.  Delivers true or false according to *	whether or not the text so delivered was empty.   */int GetDlgString(DialogPtr dlog, int item, unsigned char *str)	{		short type; Handle hndl; Rect box;		GetDialogItem(dlog,item,&type,&hndl,&box);		if (type == editText) GetDialogItemText(hndl,str);		 else                 *str = 0;		return(*str != 0);	}/* *	Retrieve the value of an edit text item in a given dialog, converting the *	Pascal string to a long and setting *val to it.  Delivers true or false *	according to whether or not the text so delivered was empty.  If false, *	*val is set to 0; if true, *val is set to whatever StringToNum() says the *	value is, even if the text contains non-numerical characters. */int GetDlgLong(DialogPtr dlog, int item, long *val)	{		int ans; unsigned char str[256];		*val = 0;		ans = GetDlgString(dlog,item,str);		if (ans)			StringToNum(str,val);		return(ans);		}/* Same as above, only delivers the value of a word */int GetDlgWord(DialogPtr dlog, int item, short *val)	{		int ans; long num;		*val = 0;		ans = GetDlgLong(dlog,item,&num);		if (ans)			*val = num;		return(ans);	}/* *	Deliver the number of the current editText item in given dialog if any text *	is selected in it, or 0 if none selected. */int TextSelected(DialogPtr dlog)	{		register TEHandle textH; int item = 0;				textH = ((DialogPeek)dlog)->textH;		if (*textH)			if ( (*textH)->selStart != (*textH)->selEnd )				item = ((DialogPeek)dlog)->editField+1;		return(item);	}/* *  If any of the variable argument scrap types are available for pasting from *  the scrap, deliver the first one.  Otherwise, deliver 0.  For example, *	 *      if (whichType = CanPaste(3,'TEXT','PICT','STUF')) ... * *  There can be any number of types in the list, as long as the preceding count, n, *  is correct. */OSType CanPaste(int n, ...)	{		register OSType nextType,ans = 0L;		long err,offset;		va_list nextArg;		#if TARGET_OS_MAC		va_start(nextArg,n);	// don't know why wont compile#endif TARGET_OS_MAC		nextType = va_arg(nextArg, OSType);				while (n-- > 0) {			err = GetScrap( nil, nextType, &offset);			if (err >= -1) {				ans = nextType;				break;				}			nextType = va_arg(nextArg, OSType);			}				va_end(nextArg);		return(ans);	}/* *	Frame or unframe a default dialog item (presumed a button) in given dialog. *	Note that you don't need to use an extra user item to do this unless you *	are doing some sort of non-standard default highlighting (not recommended). */void FrameDefault(DialogPtr dlog, int item, int frame)	{		short type; Handle hndl; Rect box;		GrafPtr oldPort; PenState oldPen;				GetPort(&oldPort); MacSetPort(dlog);		GetPenState(&oldPen);				GetDialogItem(dlog,item,&type,&hndl,&box);		MacInsetRect(&box,-4,-4);				PenSize(3,3);		if (frame) PenPat(&qd.black);		/* Paint frame */		 else      PenPat(&qd.white);		/* Erase frame */		FrameRoundRect(&box,16,16);				SetPenState(&oldPen);		MacSetPort(oldPort);	}/* *	Get rectangle, *panel, for a given item (usually a user or picture item) *	and then hide the item so that it doesn't interfere with mouse clicking. *	This lets you stop worrying about the item order any user or pict items that *	obscure other items in the item list, which can affect how the DialogMgr *	returns itemHits. */void GetDlgPanel(DialogPtr dlog, int item, Rect *panel)	{		short type; Handle hndl;				GetDialogItem(dlog,item,&type,&hndl,panel);		HideDialogItem(dlog,item);	}/* *	Build a new list in given user item box of dialog, dlog, *	with cell height, csize.  If success, delivers true; if couldn't *	allocate ListMgr list (no more memory or whatever), delivers false. */int BuildList(DialogPtr dlog, int item, int csize, userListType *l,	unsigned char *(*getCellData)(userListType *, short, short *), int listLength,	short selectedItem)	{		short i,len,type; Rect box; Handle hndl; unsigned char *data;		RGBColor	color, originalBackColor;		CWindowPeek		cwin;		/* Content area (plus scroll bar) of list corresponds to user item box */				cwin = (CWindowPeek)&(((DialogPeek)dlog)->window);		originalBackColor =  cwin->port.rgbBkColor;		MacSetPort( dlog);		color.red = color.blue = color.green = 65535;//		RGBBackColor( &color);		GetDialogItem(dlog,item,&type,&hndl,&box);		l->bounds = box; MacInsetRect(&l->bounds,-1,-1);		SetDialogItem(dlog,item,userItem, nil,&l->bounds);		l->scroll = box; l->scroll.left = l->scroll.right - 15;		/* Scrollbar width */		l->content = box; l->content.right = l->scroll.left;		MacSetRect(&l->dataBounds,0,0,1,0);		l->cSize.v = csize > 0 ? csize : 1;		l->cSize.h = l->content.right - l->content.left;		l->hndl = LNew(&l->content,&l->dataBounds,l->cSize,0,dlog,false,false,false,true);		if (l->hndl) {			(*l->hndl)->selFlags = lOnlyOne;		/* Or whatever */			l->nCells = listLength;			LAddRow(l->nCells,0,l->hndl);			for (i=0; i<l->nCells; i++) {				l->cell.h = 0; l->cell.v = i;				data = getCellData(l,i,&len);				LSetCell((Ptr)data,len,l->cell,l->hndl);				}			l->cell.v = selectedItem;			LSetSelect(true,l->cell,l->hndl);			EraseRect(&l->content);			InvalRect(&l->bounds);			LSetDrawingMode( true,l->hndl);			}//		RGBBackColor( &originalBackColor);		return(l->hndl!=nil);	}#endif/********************************************ADDED BY NRL********************************************/