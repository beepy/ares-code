/******************************************\|**| str_bp_mac.csome simple string functions were notreadily avaible; this duplicates them\******************************************/#pragma mark 본INCLUDES본/******************************************\|**| #includes\******************************************/#pragma mark _system includes_/* - system*******************************************/#include <string.h>#pragma mark _third party includes_/* - third party libraries*******************************************/#pragma mark _bp libraries includes_/* - bp libraries*******************************************/#include "Assert.h"#include "String Numerics.h"#pragma mark _this library includes_/* - this project*******************************************/#include "str_bp.h"#pragma mark 본DEFINITIONS본/******************************************\|**| #defines\******************************************//* - definitions*******************************************/#pragma mark _macros_/* - macros*******************************************/#define	mNoCapChar( mc) ( ( ( (mc) >= 'a') && ( (mc) <= 'z') ) ? ( (mc) - 'a' + 'A') : (( mc))) #define mCharIsWhiteSpace( mc) ((mc == ' ') || ( mc == '\t') || ( mc == '\r') || ( mc == '\n'))#pragma mark 본TYPEDEFS본/******************************************\|**| typedefs\******************************************/#pragma mark 본EXTERNAL GLOBALS본/******************************************\|**| external globals\******************************************/#pragma mark 본PRIVATE GLOBALS본/******************************************\|**| private globals\******************************************/#pragma mark 본PRIVATE PROTOTYPES본/******************************************\|**| private function prototypes\******************************************/#pragma mark 본PRIVATE FUNCTIONS본/******************************************\|**| private functions\******************************************/#pragma mark 본PUBLIC FUNCTIONS본/******************************************\|**| public functions\******************************************/void c2pstrcpy_bp( StringPtr dst, const char* src ){	short	l;	mAssert( dst != nil);	mAssert( src != nil);		l = strlen(src);	if ( l > 255) l = 255;	BlockMoveData(src,&dst[1], (long)l );	dst[0] = l;	//	return dst;}char *p2cstrcpy_bp( char *dst, const StringPtr src){	mAssert( dst != nil);	mAssert( src != nil);	/*	BlockMoveData( &src[1], dst, (long)src[0]);	dst[src[0]] = 0;*/	p2cstrcpy( dst, src);		return dst;}StringPtr pstrcpy_bp( StringPtr dst, const unsigned char * src){	short	l = src[0];		mAssert( dst != nil);	mAssert( src != nil);		dst[0] = l;	BlockMoveData(&src[1],&dst[1], (long)l );		return dst;}int pstrcmp( StringPtr s1, StringPtr s2){	short	i;		if ( s1 == s2) return 0;	if ( s1 == nil ) return -1;	if ( s2 == nil) return 1;			if ( s1[0] == s2[0])	{		i = 1;				while (( s1[i] == s2[i]) && ( i <= s1[0])) i++;		if ( i > s1[0]) return 0;		else if ( s1[i] < s2[i]) return -1;		else return 1;	} else	{		i = 1;				while ( s1[i] == s2[i])		{			i++;			if ( i > s1[0]) return -1;			if ( i > s2[0]) return 1;		}		if ( s1[i] < s2[i]) return -1;		return 1;	}	return 0;}int pstrcmp_nocase( StringPtr s1, StringPtr s2){	short	i;		if ( s1 == s2) return 0;	if ( s1 == nil ) return -1;	if ( s2 == nil) return 1;			if ( s1[0] == s2[0])	{		i = 1;				while (( mNoCapChar( s1[i]) == mNoCapChar( s2[i])) && ( i <= s1[0])) i++;		if ( i > s1[0]) return 0;		else if ( mNoCapChar( s1[i]) < mNoCapChar( s2[i])) return -1;		else return 1;	} else	{		i = 1;				while ( mNoCapChar( s1[i]) == mNoCapChar( s2[i]))		{			i++;			if ( i > s1[0]) return -1;			if ( i > s2[0]) return 1;		}		if ( mNoCapChar( s1[i]) < mNoCapChar( s2[i])) return -1;		return 1;	}	return 0;}StringPtr pstrcat_bp( StringPtr dst, StringPtr src){	long	len;		mAssert( dst != nil);	mAssert( src != nil);	len = dst[0];	len += src[0];		if ( len > 255) len = 255;	if ( len <= dst[0]) return dst;	BlockMoveData( &src[1], &dst[dst[0]+1], len-dst[0]);	dst[0] = len;	return dst;}StringPtr pstr_getFileExtension( StringPtr dst, StringPtr src){	long	i;		mAssert( dst != nil);	mAssert( src != nil);		if (( src == nil) || ( src == dst)) return dst;	dst[0] = 0;	i = src[0];	while (( i > 0) && ( src[i] != '.'))	{		i--;	}	if ( i == 0) return dst;	i++;	while ( i <= src[0])	{		dst[0] = dst[0] + 1;		dst[dst[0]] = mNoCapChar( src[i]);		i++;	}	return dst;}long pstr_getCharOffset( StringPtr src, char key){	long	i = 1, l;		mAssert( src != nil);	l = src[0];		while ( i <= l)	{		if ( src[i] == key) return i;		i++;	}	return 0;}StringPtr pstr_trim( StringPtr dst){	Str255		t;	long		i = 1, j;			pstrcpy( t, dst);	dst[0] = 0;	while (( i <= t[0]) && ( mCharIsWhiteSpace( t[i])))	{		i++;	}		j = t[0];	while (( j > i) && ( mCharIsWhiteSpace( t[j])))	{		j--;	}	while ( i <= j)	{		dst[0] = dst[0] + 1;		dst[dst[0]] = t[i];		i++;	}	return dst;}StringPtr pstr_copyFormat( StringPtr dst, StringPtr s, ...){	Str255		d, s2;	long		i=1;	va_list		ap;			va_start( ap, s);	d[0] = 0;	dst[0] = 0;	while ( i <= s[0])	{		if ( s[i] != '%')		{			d[0] = d[0] + 1;			d[d[0]] = s[i];			i++;		} else if ( i < s[0])		{			pstrcat( dst, d);			d[0] = 0;			i++;			switch( s[i])			{				case '%':					pstrcat( dst, "\p%");					break;								case 'l': case 'L':					{						long	l = va_arg( ap, long);						NumToString( l, s2);						pstrcat( dst, s2);					}					break;								case 'd': case 'D':					{						double	d = va_arg( ap, double);												DoubleToString( d, s2, 3);						pstrcat( dst, s2);					}					break;								case 'x': case 'X':					{						unsigned long h = va_arg( ap, unsigned long);												NumToHexString( h, s2, 4);						pstrcat( dst, "\p0x");						pstrcat( dst, s2);					}					break;								case 't': case 'T':					{						unsigned long t = va_arg( ap, unsigned long);						char	*c = (char *)&t;												s2[0] = 6;						s2[1] = '\'';						s2[2] = *c++;						s2[3] = *c++;						s2[4] = *c++;						s2[5] = *c;						s2[6] = '\'';						pstrcat( dst, s2);					}					break;								case 'f': case 'F':					{						smallFixedType f = va_arg( ap, smallFixedType);												SmallFixedToString( f, s2);						pstrcat( dst, s2);					}					break;								case 'c': case 'C':					{						char	*c = va_arg( ap, char *);												c2pstrcpy( d, c);						pstrcat( dst, d);						d[0] = 0;					}					break;								case 'p': case 'P':					{						StringPtr	p = va_arg( ap, StringPtr);												pstrcat( dst, p);					}					break;								case 's': case 'S':					pstrcat( dst, "\p> use c for c string, p for p string <");								}			i++;		} else		{			pstrcat( dst, d);			d[0] = 0;			i++;		}	}    va_end( ap);    if ( d[0] > 0)			pstrcat( dst, d);	    	return dst;}